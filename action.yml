name: Environment Deployment Active Check
description: Check whether a GitHub environment already has an active deployment for a given ref/commit.
author: remedyproduct
branding:
  icon: check-circle
  color: blue

inputs:
  token:
    description: GitHub token with access to deployments API (defaults to github.token)
    required: false
  environment:
    description: Target GitHub environment name (e.g. qa, stage, production)
    required: true
  ref:
    description: Git ref name to compare against (branch or full ref). Defaults to main.
    required: false
    default: main

outputs:
  should_deploy:
    description: "'true' if there is no active deployment for this ref in the target environment; 'false' otherwise."
    value: ${{ steps.check.outputs.should_deploy }}
  current_sha:
    description: SHA of the target ref used for comparison.
    value: ${{ steps.check.outputs.current_sha }}
  active_sha:
    description: SHA of the currently active deployment in the target environment (if any).
    value: ${{ steps.check.outputs.active_sha }}

runs:
  using: composite
  steps:
    - name: Determine active deployment for environment
      id: check
      uses: actions/github-script@v7
      env:
        INPUT_ENVIRONMENT: ${{ inputs.environment }}
        INPUT_REF: ${{ inputs.ref }}
      with:
        github-token: ${{ inputs.token || github.token }}
        script: |
          const envName = process.env.INPUT_ENVIRONMENT;
          const refInput = process.env.INPUT_REF || 'main';

          const owner = context.repo.owner;
          const repo = context.repo.repo;

          // Resolve target SHA for given ref (branch or tag)
          async function resolveTargetRef(input) {
            const raw = (input || '').trim();

            async function resolveToCommitSha(object) {
              let current = object;

              // Follow annotated tags until we reach a commit
              while (current.type === 'tag') {
                const { data: tag } = await github.rest.git.getTag({
                  owner,
                  repo,
                  tag_sha: current.sha,
                });
                current = tag.object;
              }

              if (current.type !== 'commit') {
                throw new Error(`Unsupported Git object type '${current.type}' for ref '${raw}'`);
              }

              return current.sha;
            }

            // Full refs like "refs/heads/main" or "refs/tags/v1.0"
            if (raw.startsWith('refs/')) {
              const ref = raw.replace(/^refs\//, '');
              const { data } = await github.rest.git.getRef({ owner, repo, ref });
              const sha = await resolveToCommitSha(data.object);
              return { sha, ref };
            }

            // Already in "heads/<name>" or "tags/<name>" form
            if (raw.startsWith('heads/') || raw.startsWith('tags/')) {
              const { data } = await github.rest.git.getRef({ owner, repo, ref: raw });
              const sha = await resolveToCommitSha(data.object);
              return { sha, ref: raw };
            }

            // Plain name: try branch first, then tag
            const branchRef = `heads/${raw}`;
            try {
              const { data } = await github.rest.git.getRef({ owner, repo, ref: branchRef });
              const sha = await resolveToCommitSha(data.object);
              return { sha, ref: branchRef };
            } catch (error) {
              if (error.status !== 404) throw error;
            }

            const tagRef = `tags/${raw}`;
            try {
              const { data } = await github.rest.git.getRef({ owner, repo, ref: tagRef });
              const sha = await resolveToCommitSha(data.object);
              return { sha, ref: tagRef };
            } catch (error) {
              if (error.status === 404) {
                throw new Error(`Unable to resolve ref '${raw}': neither branch nor tag found`);
              }
              throw error;
            }
          }

          const { sha: targetSha, ref: resolvedRef } = await resolveTargetRef(refInput);
          const refName = resolvedRef.replace(/^(heads|tags)\//, '');

          // List deployments for the target environment (newest first)
          const deployments = await github.paginate(
            github.rest.repos.listDeployments,
            { owner, repo, environment: envName, per_page: 20 }
          );

          let activeSha = null;
          for (const dep of deployments) {
            const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
              owner,
              repo,
              deployment_id: dep.id,
              per_page: 10,
            });

            const latestStatus = statuses[0];
            if (latestStatus && latestStatus.state === 'active') {
              activeSha = dep.sha;
              break;
            }
          }

          core.info(`environment: ${envName}`);
          core.info(`target ref input: ${refInput}`);
          core.info(`resolved ref: ${resolvedRef}`);
          core.info(`target ref name: ${refName}`);
          core.info(`target sha: ${targetSha}`);
          core.info(`active sha: ${activeSha}`);

          const shouldDeploy = !activeSha || activeSha !== targetSha;

          core.setOutput('should_deploy', shouldDeploy ? 'true' : 'false');
          core.setOutput('current_sha', targetSha);
          core.setOutput('active_sha', activeSha || '');
